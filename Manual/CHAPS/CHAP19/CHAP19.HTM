<HTML>
<!--
 	Dr. Dobb's Small C Resource CD-ROM Compilation (c) 1997 Dr. Dobb's Journal, M&T Publishing, Inc., a subsidiary of Miller Freeman, Inc. All rights reserved.
	A Small C Compiler: Language, Usage, Theory, and Design, by James E. Hendrix (c) 1986 James E. Hendrix. All rights reserved.
-->
<CENTER>
<B><H1>CHAPTER 19:<P>
GENERATED CODE</H1><P>
</CENTER>
</B>

In this chapter, a number of program fragments are presented together with the assembly language code they produce.  The idea is to become familiar with what the compiler does before seeing how it does it.  Many other examples might have been presented, but these provide a fair sampling of what the compiler does. <P>

As seen in <a href="../chap16/chap16.htm">Chapter 16</a>, the compiler can be invoked in such a way that we can enter source statements from the keyboard and observe on the screen the code which they generate.  Therefore, any of these examples can be verified easily. <P>

Before proceeding, we need to establish some basic concepts underlying the compiler's view of the CPU.  The compiler sees the CPU as a pair of 16 bit registers--primary and secondary--and a stack pointer. <P>

The primary register is the recipient of expression values.  When a unary operation is performed, the operand is placed in the primary register, and the operation is performed.  When a binary operation is performed, the left hand operand is evaluated first.  Then, when it is seen that a binary operator follows, it is pushed onto the stack while the right hand operand is evaluated--also in the primary register.  After that, the left operand is popped into the secondary register and the operation 
is performed with the result going to the primary register.  If possible, the optimizer eliminates this use of the stack by moving the left hand operand directly to the secondary register (if it is not needed for evaluating the right operand) or generating the left operand directly in the secondary register (at the point where the pop would be placed). <P>

As it employs the 8086 CPU (<a href="../append/appb.htm">Appendix B</a>), the compiler uses the AX register for the primary register and BX for the secondary register.  Both of these registers consists of a pair of 8 bit registers.  AX, for example, consists of AH (the high-order byte) and AL (the low-order byte). <P>

In the following examples, the compiler's code optimizer was allowed to operate as usual.  So the assembly code you see is the normal, optimized code.  You may find it instructive to try the <B>-NO</B> switch on these examples.  <P>

<B>Constants<P>
</B>
The examples in Listing 19-1 show two functions, each containing constant expressions as stand-alone statements.  Each statement generates a <P>

<PRE>		MOV AX,...<P>
</PRE>

instruction that moves the constant value to the primary register.  Notice also that a constant expression like <P>

<PRE>		123+321<P>
</PRE>

is evaluated by the compiler and only the result is loaded.  Since the expression yields a constant, it is evaluated at compile time rather than run time.  The advantage should be obvious. <P>

Next, notice the handling of character strings.  Each string generates <P>

<PRE>		MOV AX,OFFSET _<I>m</I>+<I>n</I><P>
</PRE>

where <I>m</I> is the number of a compiler generated label and  <I>n</I> is an offset from the label to the beginning of the string.  The operator <B>OFFSET</B> tells the assembler to place the offset part of the address in AX rather than the operand at that address.  Since Small C uses a small memory model, the offset is effectively the full address.  Thus, the presence of a character string produces in the program the address of the specified string.  All of the strings in a function are dumped into the
 data segment, one after the other, when the compiler finds the end of the function.  This literal pool for the function is preceded by a single compiler generated label.  The underscore character is acceptable in labels.  Its presence before the label number makes the assembler see the number as part of a label name rather than a number.  Notice that each string is terminated with a null byte in the standard C fashion.<P>

<CENTER>
<img src="ls19-1.gif">
</CENTER>
<B><CENTER>Listing 19-1: Code Generated by Constant Expressions<P>
</CENTER></B>

Segment directives of the form<P>

<PRE>		<I>name</I> SEGMENT PUBLIC<P>
</PRE>

tell the assembler to assemble the following code into the named segment.  Small C works with just two segments--<B>CODE </B>and <B>DATA</B>.  The assembler is switched between these segments by closing the current segment with<P>

<PRE>		<I>name</I> ENDS<P>
</PRE>

and opening the other one with another segment directive.  The result is a collection of segment fragments bearing the names <B>CODE</B> and <B>DATA</B>.  The linker combines the fragments with the same name into a single segment in the <B>EXE</B> file.  The <P>

<PRE>		ASSUME CS:CODE, SS:DATA, DS:DATA<P>
</PRE>

directives tell the assembler what to expect in the segment registers at execution time.  It needs this information in order to correctly generate offset values for memory references.  The start up routine in the <B>CALL</B> module of the library sees to it that the segment registers contain these values. <P>

Finally, in the second function, notice that character constants result in just their numeric values.  <P>

<B>Global Definitions<P>
</B>

The examples in Listing 19-2 illustrate the code generated when global objects are defined.  Integer definitions are on the left and equivalent character definitions are in corresponding positions on the right.  Each global object is first declared to the assembler as an entry point.  This is done with the <P>

<PRE>		PUBLIC <I>name</I><P>
</PRE>

directive.  As you can see, the compiler prefixes each name with a single underscore character which serves to avoid clashes with assembler reserved words. <P>
<B>DW</B> (define word) directives define integers, and <B>DB</B> (define byte) directives do the same for characters.  If no initial value is specified the <P>

<PRE>		<I>n</I> DUP (0)<P>
</PRE>

syntax is used to allocate <I>n</I> occurrences of the value zero. (Recall that uninitialized globals are guaranteed to start with initial values of zero.) However, if initial values are given, then the individual values are listed, each resulting in an occurrence of an object.  Notice that when fewer initial values than objects are given, then <I>n</I> <B>DUP (0)</B> is used to define the uninitialized trailing objects. <P>

<I>Note: The names of the objects in these examples were chosen to indicate the types of objects they are.  For example, </I><B><I>gi</B></I><I> is a global integer, </I><B><I>gca </B></I><I>is a global character array, and </I><B><I>gip</B></I><I> is a global integer pointer.  The examples which follow use the same naming conventions, except that </I><B><I>l</B></I><I> means local,  </I><B><I>a</B></I><I> means argument, and </I><B><I>e</B></I><I> means external.<P></I>

<CENTER>
<img src="ls19-2.gif">
</CENTER>
<P>
<B><CENTER>Listing 19-2: Code Generated by Global Objects<P>
</CENTER></B>

<B>Global References<P>
</B>

The examples in Listing 19-3 illustrate the code generated when global objects are referenced.  Again, integer and character examples are separated into left- and right-hand columns.  Each example is written as a very simple expression statement--just the reference in question.  This isolates the references for sake of illustration.  Of course the same code is generated when these references occur in more complicated expressions. <P>

First of all, compare the references to integers and characters.  In the first case,  <B>gi</B> is obtained by moving a word from it's place in memory as indicated by the label <B>_GI</B>.  The assembler knows to move a word instead of a byte, by the fact that the destination is a 16 bit register.  In contrast, the reference to <B>gc</B> moves only a byte to AL.  It also executes a <B>CBW</B> to convert from a byte in AL to word in AX by means of sign extension. <P>

Next look at the effect of placing an address operator (<B>&amp;</B>) in front of these references.  Since this calls for the address of the object, the <B>OFFSET</B> operator is given to the assembler so that the value of the label itself is moved to AX rather than the object at that address.  Notice here that there is no difference between the code for an integer address and a character address. <P>

<CENTER>
<img src="ls19-3.gif">
</CENTER>
<B><CENTER>Listing 19-3: Code Generated by Global References<P>
</CENTER></B>

Following these are references to array names, but without subscripts.  This should yield the address of the array.  Not surprisingly, therefore, it generates the same code as the address operator applied to a variable. <P>

When a subscript of value zero is used, the compiler simply skips the subscript arithmetic altogether and fetches the object at the array address.  Thus <B>gia[0]</B> obtains the first integer in <B>gia</B> just as <B>gi</B> obtains the integer <B>gi</B>.  Now, notice that the indirection operator (<B>*</B>) applied to an array name has the same effect as a zero subscript--it obtains the object at the designated address. <P>

The next two examples in Listing 19-3 illustrate ordinary array subscripting.  <B>Gia[5]</B> refers to the sixth integer in  <B>gia</B> by specifying the source operand in a <B>MOV</B> instruction as  <B>_GIA+10</B>.  The assembler evaluates this expression by adding ten to the address of <B>gia</B> to determine the location of the desired integer.  Since this is done at assembly time rather than run time, it has no effect on program performance.  This is possible only because the subscript is a constant.
 Had it been a variable or a more complex expression, then more code would have been generated which would have to be evaluated at run time.  Comparing the integer to the character reference, we see that the subscript value of the integer reference has been doubled since integers occupy two bytes each.  Also, a <B>CBW</B> instruction promotes the character to an integer. <P>

The next examples illustrate the equivalence of subscripting and writing the address arithmetic directly.  Notice that the same code is generated by <B>gia[5]</B>; and <B>*(gia+5)</B>;. <P>

The remaining examples in Listing 19-3 serve to compare pointer references to the previous array references.  At the source level, these are conceptually the same--unadorned references yield an address, both may be subscripted, and both may have address arithmetic performed on them.  However, they differ fundamentally in that an array name is not an lvalue, since it represents the constant address, whereas a pointer name is an lvalue since it identifies a piece of memory which can be changed.  Thus, 
an unadorned pointer name like <B>gip</B> produces an address by fetching the word at  <B>_GIP</B> instead of its address.  Since a Small C pointer is always two bytes long, regardless of whether it refers to characters or integers, the integer pointer reference generates the same code as the character pointer reference.  They both fetch the contents of the pointer which is assumed to be an address.  Of course, it is the programmer's responsibility to see that the pointer does in fact contain the correct 
address value. <P>

Placing an indirection operator (<B>*</B>) before a pointer fetches the object pointed to.  Thus  <B>*gip</B> first fetches the contents of the pointer into the secondary register BX, from which it can serve as a base address.  Then, by means of <P>

<PRE>		MOV AX,[BX]<P>
</PRE>

it moves the word pointed to by BX into AX.  The brackets can be read as contents of the memory location.  This must be a two step operation, because the value of the pointer is a variable.  It may have a different value with each execution of the reference.  Comparing the integer and character examples, we see that whereas they load the pointer value the same way, the character is fetched into AL and then promoted to an integer. <P>

Finally, the last examples in Listing 19-3 illustrate the code generated by subscripting pointers and performing address arithmetic on them.  Note that these are equivalent to array references except that the pointer's value provides the base address whereas the array's name is itself a constant address.  <P>

<B>External Declarations and References<P>
</B>

The examples in Listing 19-4 illustrate the code generated when objects are declared external.  In that case, there is no definition of the objects.  They are simply declared external to the assembler by means of <B>EXTRN</B> directives.<P>

<CENTER>
<img src="ls19-4.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-4: Code Generated by External Declarations<P>
</CENTER></B>

Listing 19-5 shows that references to external objects generate code which is identical to that which is generated for ordinary global objects.  After all, they really are global objects; they just exist in another program module.  It is up to the linker to determine the actual address for each of these references, once it has concatenated the several parts of the program into a single code segment and a single data segment.<P>

<CENTER>
<img src="ls19-5.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-5: Code Generated by External References<P>
</CENTER></B>

<B>Local Declarations and References<P>
</B>

The function in Listing 19-6 illustrates how local objects are both declared and referenced.  The function proceeds from the top of the left column to the bottom of the right column.  As before, integer references are on the left and equivalent character references are on the right. <P>

First, notice that on entry to the function, the base pointer (BP) is saved on the stack and the new stack pointer value (SP) is moved to BP as the base of the stack frame for this function call.  Had there been arguments passed to this function they would be located at positive displacements from BP, beneath the saved value of BP and the return address.  Local objects are allocated on top of the stack, and so are accessed by negative displacements from BP.<P>

Rather than decrement SP separately for each local object, the compiler defers until the first executable statement is found.  At that point a single adjustment to SP allocates all locals for the current block.  In this example, we define a character, a character array of 10 elements, and a character pointer--a total of 13 bytes.  Then we define an integer, an integer array of 10 elements, and an integer pointer--a total of 24 bytes.  These numbers combined account for the negative adjustment to SP in the
 instruction <P>

<PRE>		ADD SP,-37<P>
</PRE>

In its symbol table, the compiler keeps track of the displacement from BP to each variable.  Decrementing SP simply ensures that the stack space claimed by these locals will not be used for other purposes; it reserves the space. <P>

Next, notice that all local references involve a source operand of the form <P>

<PRE>		-<I>n</I>[BP]<P>
</PRE>

where <I>n</I> is the displacement.  When an address is needed, the load effective address instruction <B>LEA</B> is used.  This instruction loads the address of the source operand rather than the operand itself. <P>

<CENTER>
<img src="ls19-6.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-6: Code Generated by Local Objects/References<P>
</CENTER></B>

Other than the fact that locals are located relative to BP, rather than by means of labels, there is no difference between local references and global references.  This can be verified by comparing Listings 19-3 and 19-6. <P>

<B>Function Declarations and Calls<P>
</B>

The example in Listing 19-7 shows the code generated when a function with arguments is declared and when the arguments passed to it are referenced.  Again, integer references are on the left and character references are on the right. <P>

In this example, observe that while arguments are referenced like locals, there are some differences.  First, and most importantly, there is no allocation of arguments in the called function.  Instead, the arguments are pushed onto the stack at the point of the function call. <P>

The function assumes that they are already on the stack when it receives control.  If the wrong number or type of arguments are passed, the function forges ahead anyway, just as if all of the required arguments were present. <P>

Another difference is that arguments are on the stack beneath the base address in BP rather than above it.  As we said above, BP points to its original (saved) value on the stack.  Beneath that is the return address which was placed on the stack by the call instruction.  And then comes the arguments.  Since they are pushed onto the stack in the order of their appearance in the function call, the last argument is found, immediately below the return address, at <B>BP+4</B>.  The next to last argument is at 
<B>BP+6</B>, and so on.  You should recall that arrays cannot be passed.  When an array name is given as an argument, the array's address is passed.  Furthermore, since such an address exists in memory and can be changed, it is actually a pointer.  This fact can be used to advantage within the function.<P>

The last statement of the function is<P>

<PRE>		return (gi1);<P>
</PRE>

which fetches the global integer <B>gi1</B> into AX as the return value, and generates the return sequence <P>

<PRE>		POP BP
		RET

</PRE><P>

If local variables had been declared, the pop would have been preceded by an adjustment to SP to deallocate the locals and return SP to the saved value of BP. <P>

If the <B>return</B> statement is removed, the return sequence would be generated automatically.  In that case, however, no return value would be established.  Whatever happens to be in AX (actually  <B>*acp</B>) will be the return value.<P>

<CENTER>
<img src="ls19-7.gif">
</CENTER>
<CENTER><B>Listing 19-7: Code Generated by Function Arguments/References<P>
</CENTER></B>

The example in Listing 19-8 shows that the code generated when a function is called is quite straightforward.  First, each argument expression is evaluated and pushed onto the stack.  The optimizer sees to it that the global lvalues are pushed directly from memory onto the stack.  Then a count of the number of arguments is loaded into the CL register.  Next a call to the function is performed.  On return from the function, the arguments are deallocated from the stack by adding 6 to the stack 
pointer.<P>

<CENTER>
<img src="ls19-8.gif">
</CENTER>
<CENTER><B>Listing 19-8: Code Generated by Direct Function Calls<P>
</CENTER></B>

Another type of the function call is required when the function address is calculated.  The example in Listing 19-9 illustrates this situation.  Notice here that the function address (contained in <B>gia[5]</B>) is pushed onto the stack.  Then, as each argument is evaluated, the sequence<P>

<PRE>		POP BX
		XCHG AX,BX
		PUSH BX</PRE><P>

swaps the argument in AX with the function address on the stack.  This leaves the function address in AX.  However, if another argument follows, it gets pushed onto the stack again.  That way it floats on top of the stack as arguments are processed.  Then when all of the arguments have been processed, the address is not pushed onto the stack, but remains in AX.  As usual, a count of the number of arguments is loaded into CL.  Finally, the function is to be called with <P>

<PRE>		CALL AX<P>
</PRE>

which calls the function pointed to by AX.  As usual, on return, the arguments are deallocated by incrementing SP.<P>

<CENTER>
<img src="ls19-9.gif">
</CENTER>
<CENTER><B>Listing 19-9: Code Generated by Indirect Function Calls<P>
</CENTER></B>

<B>Expressions<P>
</B>

It would be easy to go on with examples of interesting expressions.  For the sake of brevity, however, only a representative sample of the various operators and one example of a fairly complex expression are illustrated.  Also, for simplicity, only global objects are referenced.  You can infer from the previous examples the effects of referencing locals and arguments. <P>

The examples in Listings 19-10 and 19-11 show the effects of unary operators.  First the logical NOT operator which is implemented as a call to <B>__LNEG()</B> in the <B>CALL</B> module.  This routine logically negates the value in AX and leaves the result in AX.<P>

<CENTER>
<img src="ls19-10.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-10: Code Generated by the Logical NOT Operator<P>
</CENTER></B>

The increment operator (Listing 19-11), applied as a prefix, adds one to the global integer <B>gi</B> in memory and leaves the incremented value in AX as the value of the operation. <P>

<CENTER>
<img src="ls19-11.gif">
</CENTER>
<CENTER><B>Listing 19-11: Code Generated by the Increment Prefix<P>
</CENTER></B>

Observe the difference, in Listing 19-12, after two changes are made.  By referring to an integer pointer rather than an integer, the increment value becomes two so that the pointer will advance to the next integer.  Then by applying the increment operator as a suffix, the original value of the operand remains in AX.  The target for the add operation is the pointer itself in memory.<P>

<CENTER>
<img src="ls19-12.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-12: Code Generated by the Increment Suffix<P>
</CENTER></B>

In Listing 19-13 the indirection operator is applied once, twice, and three times to the integer pointer <B>gip</B>.  In the first case, the word pointed to by <B>gip</B> is fetched by the sequence<P>

<PRE>		MOV BX,_GIP
		MOV AX,[BX]</PRE><P>

in which the first move obtains the pointer value in BX, and the second move uses it as the address from which the object is moved to AX.  In the second case, that object is itself used as the address of the sought object.  Therefore, the instructions <P>

<PRE>		MOV BX,AX
		MOV AX,[BX]</PRE><P>

are added to the sequence.  These move the first object to BX from which it points to the final object which is loaded into AX. <P>

The third case illustrates that there is no limit to the levels of indirection that can be applied.<P>

<CENTER>
<img src="ls19-13.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-13: Code Generated by the Indirection Operator<P>
</CENTER></B>

In Listing 19-14 the address operator is applied to a global pointer and a global array element.  In the first case, the address of <B>gip</B> is loaded into AX.  Notice that this obtains the address of the pointer, not the address it contains. <P>

Applied to the array element <B>gia[5]</B>, the address operator first loads the address of the array, then offsets it to the sixth element.  This could be optimized to <P>

<PRE>		MOV AX,OFFSET _GIA+10<P>
</PRE>

in which the addition is performed at assembly time rather than run time.  This is left as an exercise.<P>

<CENTER>
<img src="ls19-14.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-14: Code Generated by the Address Operator<P>
</CENTER></B>

The division and modulo operators (Listing 19-15) generate identical code except for the <B>MOV AX,DX</B> generated by the modulo operator.  Since <B>IDIV</B> returns the quotient in AX and the remainder in DX, this move substitutes the remainder for the quotient as the value of the operation.<P>

<CENTER>
<img src="ls19-15.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-15: Code Generated by Division and Modulo Operators<P>
</CENTER></B>

The addition operator (Listing 19-16) is not particularly remarkable.  It simply evaluates the left and right operands and performs the addition.  Since the right operand is so simple, the optimizer has combined its evaluation with the add operation.<P>

<CENTER>
<img src="ls19-16.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-16: Code Generated by the Addition Operator<P>
</CENTER></B>

The relational operators, illustrated by the equality operator in Listing 19-17, are not much different from the other binary operators.  A library routine, in this case <B>__EQ()</B>, is called to perform the comparison.  If the stated condition is true, one is returned in AX; otherwise, zero is returned.  Notice, here, that the left operand is evaluated directly in BX rather than in AX then moved to BX.  Here again, the optimizer has been at work.<P>

<CENTER>
<img src="ls19-17.gif">
</CENTER>
<CENTER><B>Listing 19-17: Code Generated by the Equality Operator<P>
</CENTER></B>

The logical AND (Listing 19-18) is interesting because during the process of evaluating a series of them, the first instance to yield false terminates the process.  The label<B> _8:</B> is the false exit point.  Any subexpression yielding false causes a jump to that label where zero (false) is loaded into AX and control proceeds on to whatever follows.<P>

<I>Note: Since the three subexpressions are tested against zero (false), in-line code is generated rather than a call to one of the comparison routines in the </I><B><I>CALL</B></I><I> module.  In each case, a bitwise OR of AX is performed on itself; this leaves the register unchanged, but sets the CPU's flags.  The zero flag is tested by </I><B><I>JNE $+5</B></I><I> which jumps around the following </I><B><I>JMP _8</B></I><I> if the flag is not set (AX is not zero).  

The expression </I><B><I>$+5</B></I><I> tells the assembler to jump 5 bytes ahead of the current location; and, since the jump instructions occupy 2 and 3 bytes respectively, this targets the next instruction.   It may seem wasteful to use two jump instructions back to back when a simple </I><B><I>JE _8 </B></I><I>would do the job.  However, the 8086 CPU does not support conditional jumps to arbitrary addresses.  Its conditional jumps are relative to the instruction pointer (IP) and only an 8-bit signed displacement is used.  This limits the
 range to -128 or +127 bytes.  Since the subexpressions could be any size, we must use an unconditional jump (which has no such limit) to reach  </I><B><I>_8</B></I><I>.  Notice that the instruction at</I><B><I> _8</B></I><I> is redundant.  <a href="../chap28/chap28.htm">Chapter 28</a> suggests improvements to this code.<P>

The logical OR operator is exactly opposite; the first term to yield true terminates the process with a value of one (true). <P>

Notice that the subexpressions operated on do not have to contain relational operators.  The last term <B>gc</B>, for instance, yields its own value which is taken for true if it is not zero, and false otherwise.<P>

<CENTER>
<img src="ls19-18.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-18: Code Generated by the Logical AND Operator<P>
</CENTER></B>

The assignment operators in Listing 19-19 are typical of all assignment operators.  First, observe the simple assignment.  Again the optimizer has been at work to produce a single instruction for setting <B>gi</B> to <B>5</B>. <P>

The  <B>+=</B> assignment is a bit more involved.  Notice that it has the same effect as the expression <P>

<PRE>		gi = gi + 5<P>
</PRE>

<B>Gi</B> is fetched, <B>5</B> is added to it, and the result is moved back to <B>gi</B>.  Since the result remains in AX, it also becomes the value of the  <B>+=</B> operator.<P>

<CENTER>
<img src="ls19-19.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-19: Code Generated by Assignment Operators<P>
</CENTER></B>

The last example of an expression (Listing 19-20) ties together several of the concepts presented above and also illustrates the flexibility with which all types of operators can be combined.  This expression first calls<B> func()</B> and assigns its returned value to <B>gc</B>. <P>

It then compares that value to <B>5</B>, yielding either true (one) or false (zero).  This in turn multiplies <B>'y' </B>(ASCII value 121) for the value to assign to <B>gi</B>.  So <B>gi</B> is set to 121 if the function returns <B>5</B>, otherwise zero.  In either case,  <B>gc</B> is set to the value returned by<B> func()</B>.<P>

<CENTER>
<img src="ls19-20.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-20: Code Generated by a Complex Expression<P>
</CENTER></B>

<B>Statements<P>
</B>

Following are samples of the code generated for each of the statements known to the compiler.  First, a simple <B>if</B> statement (Listing 19-21) is presented.  In this example, the expression being tested is only a variable.  It is loaded into AX where it is tested for true or false.  The same in-line logic as we saw in Listing 19-18 is used.  Only if <B>gi</B> is not zero is 5 assigned to it.<P>

<CENTER>
<img src="ls19-21.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-21: Code Generated by an IF Statement<P>
</CENTER></B>

The <B>if</B> statement in Listing 19-22 contains an <B>else</B> clause.  The first controlled statement <P>

<PRE>		gi = 5;<P>
</PRE>

is executed if <B>gi</B> yields true and the second statement<P>

<PRE>		gi = 10;<P>
</PRE>

is executed if it yields false.  One and only one of these statements is executed.  Notice that the first controlled statement is terminated by a jump around the second one. <P>

<CENTER>
<img src="ls19-22.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-22: Code Generated by an IF/ELSE Statement<P>
</CENTER></B>

The two <B>if</B> statements in Listing 19-23 illustrate the greater efficiency of the code generated when a test is made against zero rather than non-zero values.  The first case involves loading the constant <B>1</B> into AX and then testing it by calling <B>__NE()</B> in the <B>CALL</B> module.  This takes more space and time than the second example in which no value has to be loaded and no routine called.<P>

<CENTER>
<img src="ls19-23.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-23: Code Generated by Non-zero and Zero Tests<P>
</CENTER></B>

The <B>switch</B> statement is the most complicated of the Small C statements, but it is not really difficult to grasp.  A typical <B>switch</B> statement is shown in Listing 19-24.  <P>

<CENTER>
<img src="ls19-24.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-24: Code Generated by a SWITCH Statement<P>
</CENTER></B>

In this example, notice that the immediate effect of a <B>case</B> or <B>default</B> prefix is to generate a label.  Later, at the end of the statement, a pair of words is generated for each <B>case</B>.  They consist of the address (label) of the <B>case</B> and the value of the <B>switch</B> expression which targets that address.  First, the <B>switch</B> expression <B>gc</B> is evaluated, and placed in AX.  Then a jump around the statements controlled by the <B>switch</B> is performed.  
Here a call is made to <B>__SWITCH()</B> which scans the following list of address/value word pairs looking for a match with the value in AX.  On the first match, <B>__SWITCH()</B> jumps to the corresponding label.  If no match is found (detected by the zero at the end of the list), control goes to the point following the list.  The jump found here is created by the <B>default</B> prefix.  Had there been no <B>default</B> there would have been no jump, and control would simply skip over the statements 
controlled by the  <B>switch</B> statement.  Notice that consecutive <B>case</B> prefixes work fine and provide a means for targeting several values of the <B>switch</B> expression to the same point.  This example makes it clear that once control begins at some point within the statements controlled by the <B>switch</B> statement, it falls straight down through the remaining statements without regard for subsequent <B>case/default</B> prefixes.  To break the fall, a <B>break</B>, <B>continue</B>, or 
<B>goto</B> statement is required.  Notice that the <B>break</B> statement generates a jump to the terminal label.  Also notice that a similar jump follows the last controlled statement.  This prevents control from reaching the call to <B>__SWITCH()</B> again.<P>

The <B>while</B> statement has a particularly simple structure in assembly language, as the example in Listing 19-25 shows.  In this example, the control variable <B>gi</B> is decremented with each iteration and checked for true or false.  If it is false (zero) then a jump to the terminal label is performed.  Otherwise, the function call is performed and a jump back to the top is executed.  The loop continues until the tested expression becomes false.<P>

<CENTER>
<img src="ls19-25.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-25: Code Generated by a WHILE Statement<P>
</CENTER></B>

The <B>for</B> statement (Listing 19-26) begins by evaluating the first of three expressions in parentheses.  This is the initializing expression.  Next, the second expression, the controlling expression, is evaluated and tested.  If it yields false, a jump to the terminal label is performed.  Otherwise, there is a jump to the controlled statement.  After that, there is a jump back to the instructions which evaluate the third expression.  This is where a control variable is 
usually incremented or decremented.  After that, there is a jump back for another evaluation of the control expression, and the process repeats itself until the control expression evaluates false.<P>

<CENTER>
<img src="ls19-26.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-26: Code Generated by a FOR Statement<P>
</CENTER></B>

The sample <B>for</B> statement in Listing 19-27 is interesting because it illustrates what happens when the three expressions in parentheses are omitted.  If any of these expressions is missing, there is simply no code generated in its place.  Eliminating all three expressions makes it equivalent to <P>

<PRE>		while (1) ...<P>
</PRE>

However, the code is less efficient because of the extra jumping around.<P>

<CENTER>
<img src="ls19-27.gif">
</CENTER>
<CENTER><B>Listing 19-27: Code Generated by a FOR Without Expressions<P>
</CENTER></B>

The <B>do/while</B> statement is simply an inverted <B>while</B> in which the controlling expression is evaluated last.  There is always at least one execution of the controlled statement.  The example in Listing 19-28 illustrates the code generated for such a statement.<P>

<CENTER>
<img src="ls19-28.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-28: Code Generated by a DO/WHILE Statement<P>
</CENTER></B>

As an example of the <B>goto</B> statement, consider the example in Listing 19-29.  Here a label is written, followed by an assignment statement and then a <B>goto</B> that targets the label.  The source label translates to a unique numeric label since the same source label can be used legally in different functions.  If the source label were used directly, the assembler might flag &quot;duplicate label&quot; errors.  The <B>goto</B> itself simply generates an unconditional jump to the target
 label.<P>

<CENTER>
<img src="ls19-29.gif">
</CENTER>
<P>
<CENTER><B>Listing 19-29: Code Generated by a GOTO Statement<P>
</CENTER></B>

<B>Conclusion<P>
</B>

This finishes our overview of the code generated by the Small C compiler.  Many other situations could have been presented, but the combinations are endless.  These should suffice to illustrate the task performed by the compiler, and to make the compiler's output understandable. <P>

Of course, you can test the compiler further yourself.  The simplest way is to invoke it without command-line arguments.  Then enter source statements from the keyboard and watch on the screen what the compiler generates.  Whenever there is doubt as to what the compiler does with some particular statement, just ask it.<P>

<P>
<CENTER>
Goto<a href="../chap20/chap20.htm"> Chapter 20</a>         Return to <a href="../toc1.htm">Table of Contents</a><P>
</CENTER>
<P>
</HTML>
